# -*- coding: utf-8 -*-
"""HDoutliers_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18ikUiCCby-Qn2CZzwcsWTUWaT0905P5F
"""

# Initial Set-up
!pip install prince
!pip install umap-learn


import pandas as pd
import numpy as np
import math
import prince
import umap

import sklearn
from pandas.api.types import is_numeric_dtype
from sklearn.neighbors import KDTree
from sklearn.neighbors import NearestNeighbors
from sklearn.manifold import TSNE
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split

from scipy import io
import timeit #for counting running time
from google.colab import drive
drive.mount('/content/gdrive')

def dataTrans(data):
    ## Input: data:pd.DataFrame
    if data.isnull().any().sum()  > 0 :
        raise ValueError("missing values not allowed")

    cte = {}
    for col in data.columns: 
        cte[col] = (len(data[col].drop_duplicates())==1) 
    if all(cte.values()):
        print("[Warning] all columns have a constant values")
        return None
    elif any(cte.values()):
        print("some columns have a constant values")

    ## del
    for col in data.columns:
        if cte[col]:del data[col] 

    CAT = {}
    for col in data.columns: 
        CAT[col] = is_numeric_dtype(data[col]) 

    if any(CAT.values()):
        mca = prince.MCA(n_components=1,) 
        for k,v in CAT.items():
            if not v:
                k_numpy = data[k].to_numpy().reshape(-1, 1)
                data[k] = mca.fit(k_numpy).transform(k_numpy)

    def unitize(col): 
        col_min, col_max = col.min(), col.max()
        if col_min == col_max: 
            return 0
        else:
            return col.apply(lambda x: (x-col_min)/(col_max-col_min))
    for col in data.columns:
        data[col] = unitize(data[col])

    return data

def getHDmembers(data, maxrows = 10000, radius = None):
    ## data:pd.DataFrame
    n = len(data)
    p = len(data.columns)
    if radius is None:
        radius = 0.1/(math.log(n)**(1/p))

    data = data.reset_index(drop=True)
    if n <= maxrows:
        ## get duplicate index
        data1 = data[data.duplicated(keep=False)]
        gb = data1.groupby(data1.columns.tolist()).apply(lambda x: list(x.index))
        if len(gb) >= 1:
            members = gb.tolist()
        else:
            members = []

        ## append not duplicate index
        for mem in list(data[~data.duplicated(keep=False)].index):
            members.append([mem])
        sorted(members, key=lambda x:x[0])
        # m = len(data.drop_duplicates(keep='first'))
        # members = list(data.index)

    else:
        members = [None for m in range(n)]
        exemplars = [0]
        members[0] = [0]
        for i in range(1,n):
            if len(exemplars) == 1:
                arr0 = data.loc[0].to_numpy().reshape(1,-1)
                arr1 =  np.append(arr0,arr0,axis=0)
                kdt = KDTree(arr1)
                dis,idx = kdt.query(data.loc[1].to_numpy().reshape(1,-1), k=2)
                d, m = dis[0][0], 0
            else:
                kdt = KDTree(data.loc[exemplars])
                dis,idx = kdt.query(data.loc[i].to_numpy().reshape(1,-1), k=2)
                d, m = dis[0][0], idx[0][0]
            if d < radius:
                l = exemplars[m]
                members[l].append(i)
                continue
            exemplars.append(i)
            members[i] = [i]
            
        tem_members = []
        for m in members:
            if m is None :continue
            tem_members.append(m)
        members = tem_members
        
    return members

def getHDoutliers(data, memberLists, alpha = 0.05, transform = True): 
  
    if transform:
        data = dataTrans(data)

    if data.isnull().any().sum()  > 0 :
        raise ValueError("missing values not allowed")

    exemplars = [mem[0] for mem in memberLists]

    nbrs = NearestNeighbors(n_neighbors=2).fit(data.loc[exemplars])
    distances, indices = nbrs.kneighbors(data.loc[exemplars])
    d = distances[:,1]
    n = len(d)

    ## getOrder
    d1 = pd.DataFrame(distances,columns=['dis0','dis1'])
    ord_ = list(d1.sort_values('dis1').index)
    d_order = d1.sort_values('dis1')['dis1'].tolist()
    dmin = d.min()
    dmax = d.max()

    d1 = pd.DataFrame(distances,columns=['dis0','dis1'])
    d1 = d1.sort_values('dis1')
    d1['dis1_shift'] = d1['dis1'].shift(1)
    d1['gaps'] = (d1['dis1'] - d1['dis1_shift']).fillna(0)
    gaps = d1['gaps'].tolist()
    n4 = max(min(50, math.floor(n/4)), 2)
    J = range(n4)
    start = max(math.floor(n/2), 1) 
    ghat = [0] * n
    for i in range(start,n):
        ghat[i]  = sum(np.multiply([j_/n4 for j_ in J] , gaps[ i - n4 : i ][::-1]))  
    logAlpha = math.log(1/alpha) 
    bound = float('inf')
    for i in range(start,n):
        if gaps[i] > logAlpha * ghat[i]:
            bound = d_order[i-1]
            break
    ex = []
    for i, d0 in enumerate(d):
        if d0 > bound:ex.append(i)

    out = []
    for i in ex:
        out.extend(memberLists[i])

    return out

def HDoutliers(data, alpha, maxrows=10000,radius=None, transform = True):
  # main function
  if transform is True:
    data = dataTrans(data)
  members = getHDmembers(data,radius=radius,maxrows=maxrows)
  return getHDoutliers(data,members, alpha=alpha, transform = False )